<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Aura - Asistente por voz para personas con discapacidad visual">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Aura">

  <!-- Favicon -->

  <title>Aura</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

  <style>
    @font-face {
      font-family: 'Pecita';
      src: url('https://fonts.cdnfonts.com/s/21045/Pecita.woff') format('woff');
      font-style: normal;
      font-weight: 400;
      font-display: swap;
    }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #1a0e3b;
      font-family: 'Pecita', 'Pacifico', cursive, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      perspective: 1000px;
    }
    
    .text-area {
      margin: 20px;
      padding: 20px;
      max-width: 600px;
      height: 80px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    /* Estilos para el texto animado */
    .aura-text {
      font-family: 'Pecita', cursive;
      font-size: 60px;
      color: white;
      margin-bottom: 30px;
      position: relative;
      display: inline-block;
      white-space: nowrap;
      font-weight: 300;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
      opacity: 0.85;
      letter-spacing: 2px;
    }
    
    .aura-text span {
      opacity: 0;
      position: relative;
      display: inline-block;
      animation-name: fadeIn;
      animation-duration: 0.5s;
      animation-fill-mode: forwards;
    }
    
    .aura-text span:nth-child(1) {
      animation-delay: 0.2s;
    }
    
    .aura-text span:nth-child(2) {
      animation-delay: 0.7s;
    }
    
    .aura-text span:nth-child(3) {
      animation-delay: 1.2s;
    }
    
    .aura-text span:nth-child(4) {
      animation-delay: 1.7s;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .orb-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin: 40px 0;
      transform-style: preserve-3d;
      perspective: 1000px;
      opacity: 0; /* Inicialmente oculto */
      transform: scale(0.8);
      transition: opacity 1.5s ease-in-out, transform 1.5s ease-in-out;
    }
    
    .orb-container.visible {
      opacity: 1;
      transform: scale(1);
    }
    
    .siri-orb {
      position: absolute;
      width: 280px;
      height: 280px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotateX(0deg) rotateY(0deg);
      border-radius: 50%;
      background-color: rgba(0, 0, 50, 0.1);
      transform-style: preserve-3d;
      transition: transform 0.2s ease-out;
      overflow: hidden;
      box-shadow: 
        0 0 40px var(--orb-glow),
        0 0 80px rgba(0, 191, 255, 0.4),
        inset 0 0 30px rgba(0, 191, 255, 0.2);
    }
    
    /* Fondo del orbe con degradado similar a la imagen */
    .orb-background {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(
        circle at center,
        rgba(0, 0, 60, 0.2),
        rgba(0, 0, 80, 0.6) 80%
      );
      z-index: 1;
    }
    
    /* Contenedor para las líneas curvas */
    .curved-lines-container {
      position: absolute;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      z-index: 2;
    }
    
    /* Líneas curvas similares a la imagen */
    .curved-line {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      border-radius: 50%;
      overflow: hidden;
      opacity: 0.7;
    }
    
    .curved-line-1 {
      background: conic-gradient(
        from 0deg,
        transparent 0%,
        transparent 20%,
        var(--orb-blue) 30%,
        var(--orb-white) 40%,
        transparent 50%,
        transparent 100%
      );
      animation: rotate 20s linear infinite;
    }
    
    .curved-line-2 {
      background: conic-gradient(
        from 120deg,
        transparent 0%,
        transparent 20%,
        var(--orb-purple) 30%,
        var(--orb-white) 40%,
        transparent 50%,
        transparent 100%
      );
      animation: rotate 25s linear infinite reverse;
    }
    
    .curved-line-3 {
      background: conic-gradient(
        from 240deg,
        transparent 0%,
        transparent 20%,
        var(--orb-pink) 30%,
        var(--orb-white) 40%,
        transparent 50%,
        transparent 100%
      );
      animation: rotate 30s linear infinite;
    }
    
    /* Líneas de luz que se cruzan */
    .light-beam {
      position: absolute;
      width: 300px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(
        90deg,
        transparent,
        var(--orb-blue),
        var(--orb-white),
        var(--orb-blue),
        transparent
      );
      transform-origin: center;
      opacity: 0.8;
      filter: blur(1px);
      z-index: 3;
    }
    
    .beam-1 {
      transform: translate(-50%, -50%) rotate(45deg);
    }
    
    .beam-2 {
      transform: translate(-50%, -50%) rotate(135deg);
      background: linear-gradient(
        90deg,
        transparent,
        var(--orb-purple),
        var(--orb-white),
        var(--orb-purple),
        transparent
      );
    }
    
    /* Efecto de ondas */
    .wave-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      z-index: 4;
      overflow: hidden;
    }
    
    .wave {
      position: absolute;
      width: 200%;
      height: 200%;
      top: -50%;
      left: -50%;
      background: repeating-radial-gradient(
        circle at center,
        transparent 0px,
        transparent 5px,
        rgba(0, 191, 255, 0.05) 6px,
        transparent 7px,
        transparent 10px
      );
      opacity: 0.5;
      animation: pulse 8s infinite alternate ease-in-out;
    }
    
    .wave-2 {
      background: repeating-radial-gradient(
        circle at center,
        transparent 0px,
        transparent 8px,
        rgba(138, 43, 226, 0.05) 9px,
        transparent 10px,
        transparent 15px
      );
      animation: pulse 10s infinite alternate-reverse ease-in-out;
    }
    
    /* Centro brillante */
    .bright-center {
      position: absolute;
      width: 100px;
      height: 100px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(
        circle at center,
        var(--orb-white) 0%,
        rgba(255, 255, 255, 0.8) 20%,
        rgba(0, 191, 255, 0.5) 40%,
        rgba(138, 43, 226, 0.3) 60%,
        transparent 80%
      );
      filter: blur(5px);
      z-index: 5;
    }
    
    /* Líneas curvas SVG */
    .svg-container {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 6;
    }
    
    /* Efectos de luz y brillo */
    .glow-effect {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-shadow: 
        inset 0 0 30px rgba(0, 191, 255, 0.3),
        inset 0 0 60px rgba(138, 43, 226, 0.2);
      z-index: 7;
    }
    
    /* Efecto de cristal */
    .orb-glass {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(
        circle at 30% 30%,
        rgba(255, 255, 255, 0.1),
        rgba(0, 0, 60, 0.2) 80%
      );
      box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      z-index: 9;
    }
    
    /* Reflejos */
    .reflection {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      z-index: 10;
      overflow: hidden;
    }
    
    .reflection-top {
      position: absolute;
      width: 140%;
      height: 100%;
      top: -70%;
      left: -20%;
      background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.3),
        transparent 60%
      );
      transform: rotate(25deg);
      border-radius: 50%;
      filter: blur(2px);
    }
    
    .reflection-spot {
      position: absolute;
      width: 20px;
      height: 20px;
      top: 25%;
      left: 30%;
      background: radial-gradient(
        circle at center,
        rgba(255, 255, 255, 0.9),
        transparent 80%
      );
      border-radius: 50%;
      filter: blur(1px);
    }
    
    /* Borde del orbe */
    .orb-border {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 1px solid rgba(0, 191, 255, 0.3);
      box-shadow: 
        inset 0 0 20px rgba(0, 191, 255, 0.2),
        0 0 15px rgba(0, 191, 255, 0.3);
      z-index: 12;
    }
    
    /* Fondo con gradiente */
    .bg-gradient {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        135deg,
        #6b5de5 0%,
        #8a7af2 25%,
        #f27dcf 50%,
        #f5a58d 75%,
        #f9c98d 100%
      );
      z-index: -1;
      animation: gradientShift 15s infinite alternate ease-in-out;
    }
    
    @keyframes gradientShift {
      0% {
        background-position: 0% 0%;
      }
      100% {
        background-position: 100% 100%;
      }
    }
    
    .response-area {
      margin-top: 30px;
      min-height: 80px;
      text-align: center;
      font-family: 'Pecita', 'Pacifico', cursive;
      font-weight: 400;
      font-size: 20px;
      opacity: 0.9;
    }

    /* Estilos para la aplicación Flutter */
    #flutter-app {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }
    
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 30;
    }
    
    .loading-text {
      margin-top: 20px;
      font-size: 24px;
      letter-spacing: 1px;
    }
    
    #camera-feed {
      position: absolute;
      width: 2px;
      height: 2px;
      opacity: 0.01;
      pointer-events: none;
      right: 0;
      bottom: 0;
      z-index: -1;
    }

    /* Animaciones más dinámicas */
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.05); opacity: 0.7; }
      100% { transform: scale(1); opacity: 0.5; }
    }
    
    /* Colores basados en la imagen de referencia */
    :root {
      --orb-blue: #00BFFF;
      --orb-blue-dark: #0080FF;
      --orb-purple: #8A2BE2;
      --orb-pink: #FF69B4;
      --orb-white: #FFFFFF;
      --orb-glow: rgba(0, 191, 255, 0.5);
    }
  </style>

  <script>
    // La función `serviceWorkerVersion` se reemplazará con la versión del service worker durante el build.
    var serviceWorkerVersion = null;
  </script>
  <!-- Este script agrega el flutter-specific service worker y lo habilita -->
  <!-- <script src="flutter.js" defer></script> -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
</head>
<body>
  <div class="bg-gradient"></div>
  
  <div class="loading-screen">
    <div class="container">
      <div class="text-area">
        <!-- Texto Aura con animación letra por letra -->
        <h1 class="aura-text">
          <span>A</span><span>u</span><span>r</span><span>a</span>
        </h1>
      </div>
      
      <div class="orb-container" id="orb-container">
        <div class="siri-orb" id="siri-orb">
          <div class="orb-background"></div>
          
          <!-- Líneas curvas basadas en la imagen de referencia -->
          <div class="curved-lines-container">
            <div class="curved-line curved-line-1"></div>
            <div class="curved-line curved-line-2"></div>
            <div class="curved-line curved-line-3"></div>
          </div>
          
          <!-- Líneas de luz que se cruzan -->
          <div class="light-beam beam-1"></div>
          <div class="light-beam beam-2"></div>
          
          <!-- Efecto de ondas -->
          <div class="wave-effect">
            <div class="wave"></div>
            <div class="wave wave-2"></div>
          </div>
          
          <!-- Centro brillante -->
          <div class="bright-center"></div>
          
          <!-- Contenedor SVG para líneas curvas precisas -->
          <div class="svg-container">
            <svg width="100%" height="100%" viewBox="0 0 280 280">
              <!-- Curvas similares a la imagen -->
              <path d="M140,40 Q200,140 140,240" fill="none" stroke="rgba(0,191,255,0.6)" stroke-width="1" />
              <path d="M140,40 Q80,140 140,240" fill="none" stroke="rgba(138,43,226,0.6)" stroke-width="1" />
              <path d="M40,140 Q140,80 240,140" fill="none" stroke="rgba(255,105,180,0.6)" stroke-width="1" />
              <path d="M40,140 Q140,200 240,140" fill="none" stroke="rgba(0,191,255,0.6)" stroke-width="1" />
            </svg>
          </div>
          
          <!-- Efectos de luz y brillo -->
          <div class="glow-effect"></div>
          
          <!-- Efecto de cristal -->
          <div class="orb-glass"></div>
          
          <!-- Reflejos -->
          <div class="reflection">
            <div class="reflection-top"></div>
            <div class="reflection-spot"></div>
          </div>
          
          <!-- Borde del orbe -->
          <div class="orb-border"></div>
        </div>
      </div>
    </div>
  </div>
  
  <video id="camera-feed" autoplay playsinline muted></video>
  <div id="flutter-app"></div>

  <script>
    // Variables globales para reconocimiento de voz y objetos
    let recognition;
    let objectDetectionModel;
    let imageClassificationModel;
    let isListening = false;
    let isProcessing = false;
    let lastDetectedObjects = [];
    let lastDetectionTime = 0;
    let synth = window.speechSynthesis;
    let cameraStream = null;
    let microphoneStream = null;
    
    // Variables para controlar la animación
    document.addEventListener('DOMContentLoaded', function() {
      console.log('=== ASISTENTE DE VOZ INICIALIZANDO ===');
      const orbContainer = document.getElementById('orb-container');
      const siriOrb = document.getElementById('siri-orb');
      
      // Mostrar el orb después de que termine la animación de texto (2.5s)
      setTimeout(function() {
        console.log('Mostrando orbe...');
        orbContainer.classList.add('visible');
        initOrbInteraction(orbContainer, siriOrb);
      }, 2500);
    });
    
    // Función para hacer que el orbe pulse cuando está escuchando
    function pulsateOrb(isActive) {
      const siriOrb = document.getElementById('siri-orb');
      if (siriOrb) {
        if (isActive) {
          siriOrb.style.animation = 'pulse 1s infinite alternate';
        } else {
          siriOrb.style.animation = '';
        }
      }
    }
    
    // Síntesis de voz para responder
    function speak(text) {
      console.log('Hablando:', text);
      // Cancelar cualquier síntesis previa
      if (synth.speaking) {
        synth.cancel();
      }
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'es-ES';
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      
      // Evento para animación del orbe mientras habla
      utterance.onstart = function() {
        pulsateOrb(true);
      };
      
      utterance.onend = function() {
        pulsateOrb(false);
        isProcessing = false;
      };
      
      utterance.onerror = function() {
        pulsateOrb(false);
        isProcessing = false;
      };
      
      synth.speak(utterance);
    }
    
    // Declaración de processVoiceCommand (se definirá más adelante)
    let processVoiceCommand;
    
    // Inicializar reconocimiento de voz
    function initSpeechRecognition() {
      // Comprobar si el navegador soporta el reconocimiento de voz
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        // Crear instancia de reconocimiento de voz
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        
        // Configurar reconocimiento
        recognition.lang = 'es-ES';
        recognition.continuous = false;
        recognition.interimResults = false;
        
        // Manejar eventos de reconocimiento
        recognition.onstart = function() {
          isListening = true;
          pulsateOrb(true); // Efecto visual en el orbe
          console.log('Escuchando...');
        };
        
        recognition.onresult = function(event) {
          const transcript = event.results[0][0].transcript.toLowerCase();
          const confidence = Math.round(event.results[0][0].confidence * 100);
          console.log(`Has dicho: "${transcript}" (confianza: ${confidence}%)`);
          
          // Procesar el comando de voz
          processVoiceCommand(transcript);
        };
        
        recognition.onend = function() {
          isListening = false;
          pulsateOrb(false);
          console.log('Reconocimiento de voz finalizado');
        };
        
        recognition.onerror = function(event) {
          isListening = false;
          pulsateOrb(false);
          console.error('Error en reconocimiento:', event.error);
          if (event.error === 'no-speech') {
            speak('No he oído nada. ¿Puedes intentarlo de nuevo?');
          } else {
            speak('Ha ocurrido un error con el reconocimiento de voz.');
          }
        };
        
        console.log('Reconocimiento de voz inicializado');
        return true;
      } else {
        console.error('El navegador no soporta reconocimiento de voz');
        speak('Lo siento, tu navegador no soporta reconocimiento de voz.');
        return false;
      }
    }
    
    // Definir startListening globalmente antes de usarla
    window.startListening = function() {
      console.log('startListening llamada');
      if (isProcessing) {
        console.log('Ya estoy procesando una solicitud, por favor espera...');
        return;
      }
      
      if (!recognition) {
        console.log('Inicializando reconocimiento de voz...');
        if (!initSpeechRecognition()) {
          return;
        }
      }
      
      try {
        console.log('Iniciando reconocimiento...');
        recognition.start();
        pulsateOrb(true);
      } catch (err) {
        console.error('Error al iniciar reconocimiento:', err);
        
        // Si hay un error porque ya está escuchando, lo detenemos y reiniciamos
        if (err.name === 'InvalidStateError') {
          recognition.stop();
          setTimeout(() => {
            recognition.start();
          }, 200);
        }
      }
    };
    
    // Función para inicializar las interacciones del orb
    function initOrbInteraction(orbContainer, siriOrb) {
      // Variables para el seguimiento del movimiento del mouse
      let mouseX = 0;
      let mouseY = 0;
      let targetX = 0;
      let targetY = 0;
      let isMoving = false;
      
      // Movimiento suave basado en el movimiento del mouse
      document.addEventListener('mousemove', function(e) {
        // Calcular la posición relativa del mouse
        mouseX = (e.clientX / window.innerWidth - 0.5) * 2; // -1 a 1
        mouseY = (e.clientY / window.innerHeight - 0.5) * 2; // -1 a 1
        
        isMoving = true;
      });
      
      // Función de animación para un movimiento más suave
      function animateOrb() {
        if (isMoving) {
          // Interpolación suave
          targetX += (mouseX * 15 - targetX) * 0.1;
          targetY += (mouseY * -15 - targetY) * 0.1;
          
          // Aplicar rotación con límites
          siriOrb.style.transform = `translate(-50%, -50%) rotateY(${targetX}deg) rotateX(${targetY}deg)`;
          
          // Las animaciones CSS se encargan ahora de las rotaciones de las capas internas
        }
        
        requestAnimationFrame(animateOrb);
      }
      
      // Iniciar la animación
      animateOrb();
      
      // Soporte para dispositivos móviles
      siriOrb.addEventListener('touchmove', function(e) {
        e.preventDefault();
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          mouseX = (touch.clientX / window.innerWidth - 0.5) * 2;
          mouseY = (touch.clientY / window.innerHeight - 0.5) * 2;
          isMoving = true;
        }
      });
      
      // Soporte para giroscopio en dispositivos móviles
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function(e) {
          if (e.beta && e.gamma) {
            mouseX = e.gamma / 45; // Convertir a un rango aproximado de -1 a 1
            mouseY = e.beta / 45; // Convertir a un rango aproximado de -1 a 1
            isMoving = true;
          }
        });
      }
      
      // Efecto de clic/toque
      siriOrb.addEventListener('mousedown', function() {
        siriOrb.style.transform = `translate(-50%, -50%) rotateY(${targetX}deg) rotateX(${targetY}deg) scale(0.95)`;
      });
      
      siriOrb.addEventListener('mouseup', function() {
        siriOrb.style.transform = `translate(-50%, -50%) rotateY(${targetX}deg) rotateX(${targetY}deg) scale(1)`;
      });
      
      siriOrb.addEventListener('touchstart', function() {
        siriOrb.style.transform = `translate(-50%, -50%) rotateY(${targetX}deg) rotateX(${targetY}deg) scale(0.95)`;
        startListening(); // Activar reconocimiento de voz al tocar el orbe
      });
      
      siriOrb.addEventListener('touchend', function() {
        siriOrb.style.transform = `translate(-50%, -50%) rotateY(${targetX}deg) rotateX(${targetY}deg) scale(1)`;
      });
      
      // Activar reconocimiento de voz al hacer clic en el orbe
      siriOrb.addEventListener('click', function() {
        console.log('Click en el orbe detectado');
        // Verificar que startListening esté disponible
        if (typeof startListening === 'function') {
          console.log('Llamando a startListening...');
          startListening();
        } else {
          console.error('startListening no está definida aún');
        }
      });
    }
    
    // Inicializar reconocimiento de objetos
    async function initObjectDetection() {
      try {
        console.log('Cargando modelos de detección de objetos...');
        // Cargar modelo COCO-SSD para detección de objetos
        objectDetectionModel = await cocoSsd.load();
        
        // Cargar MobileNet para clasificación más detallada
        imageClassificationModel = await mobilenet.load();
        
        console.log('Modelos de detección de objetos cargados correctamente');
        speak('Asistente por voz listo para ayudarte');
      } catch (error) {
        console.error('Error al cargar modelos de detección:', error);
        speak('No he podido cargar los modelos de detección. Por favor, revisa tu conexión a internet.');
      }
    }
    
    // Procesar comandos de voz
    processVoiceCommand = async function(command) {
      isProcessing = true;
      
      // Convertir a minúsculas y eliminar signos de puntuación
      command = command.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
      
      console.log('Procesando comando:', command);
      
      // Detectar qué tipo de solicitud es
      if (command.includes('qué ves') || command.includes('que ves') || 
          command.includes('qué estás viendo') || command.includes('qué hay') || 
          command.includes('que hay') || command.includes('describe lo que ves')) {
        // Solicitud para describir lo que ve la cámara
        await detectObjects();
      }
      else if (command.includes('precio') || command.includes('cuesta') || 
               command.includes('vale')) {
        // Solicitud para leer precios
        await readPrice(command);
      }
      else if (command.includes('cómo llegar') || command.includes('como llegar') || 
               command.includes('llegar a') || command.includes('dirección') || 
               command.includes('direccion') || command.includes('guíame') || 
               command.includes('guiame')) {
        // Solicitud de navegación
        provideNavigation(command);
      }
      else if (command.includes('reconoce') || command.includes('detecta') || 
               command.includes('identifica')) {
        // Solicitud para reconocer un objeto específico
        await detectSpecificObject(command);
      }
      else if (command.includes('hola') || command.includes('ayuda') || 
               command.includes('qué puedes hacer') || command.includes('que puedes hacer')) {
        // Saludo o solicitud de ayuda
        console.log('Comando de saludo/ayuda detectado');
        speak('Hola, soy Aura, tu asistente por voz. Puedo reconocer objetos, leer precios, darte indicaciones y ayudarte a identificar billetes, monedas y productos. Pregúntame qué veo, cómo llegar a un sitio o el precio de un producto.');
      }
      else {
        // Comando no reconocido
        speak('Lo siento, no he entendido tu solicitud. Puedes pedirme que describa lo que veo, que te diga el precio de un producto, o cómo llegar a un lugar.');
        isProcessing = false;
      }
    }
    
    // Función para detectar objetos en la cámara
    async function detectObjects() {
      speak('Analizando lo que veo...');
      
      const videoElement = document.getElementById('camera-feed');
      if (!videoElement || !cameraStream || !objectDetectionModel) {
        speak('Lo siento, no puedo acceder a la cámara o el modelo de detección no está cargado.');
        isProcessing = false;
        return;
      }
      
      try {
        // Asegurarse de que el video esté reproduciendo
        if (videoElement.paused) {
          await videoElement.play();
        }
        
        // Detectar objetos
        const predictions = await objectDetectionModel.detect(videoElement);
        
        if (predictions && predictions.length > 0) {
          lastDetectedObjects = predictions;
          lastDetectionTime = Date.now();
          
          let response = 'Veo ';
          
          predictions.forEach((prediction, index) => {
            const object = translateObject(prediction.class);
            const confidence = Math.round(prediction.score * 100);
            
            if (index === 0) {
              response += `${object} con ${confidence}% de confianza`;
            } else if (index === predictions.length - 1) {
              response += ` y ${object} con ${confidence}% de confianza`;
            } else {
              response += `, ${object} con ${confidence}% de confianza`;
            }
          });
          
          speak(response);
        } else {
          speak('No puedo identificar ningún objeto en este momento. Por favor, ajusta la cámara o prueba con mejor iluminación.');
        }
      } catch (error) {
        console.error('Error al detectar objetos:', error);
        speak('Ha ocurrido un error al analizar la imagen. Por favor, inténtalo de nuevo.');
      }
      
      isProcessing = false;
    }
    
    // Función para detectar un objeto específico
    async function detectSpecificObject(command) {
      speak('Buscando ese objeto específico...');
      
      // Extraer qué objeto está solicitando el usuario
      let targetObject = '';
      const keywords = [
        'reconoce', 'detecta', 'identifica', 'busca', 'encuentra'
      ];
      
      for (const keyword of keywords) {
        if (command.includes(keyword)) {
          const parts = command.split(keyword);
          if (parts.length > 1 && parts[1].trim()) {
            targetObject = parts[1].trim();
            break;
          }
        }
      }
      
      if (!targetObject) {
        speak('No he entendido qué objeto quieres que reconozca. Por favor, especifica qué debo buscar.');
        isProcessing = false;
        return;
      }
      
      // Detectar todos los objetos y filtrar
      const videoElement = document.getElementById('camera-feed');
      if (!videoElement || !cameraStream || !objectDetectionModel) {
        speak('Lo siento, no puedo acceder a la cámara o el modelo de detección no está cargado.');
        isProcessing = false;
        return;
      }
      
      try {
        // Asegurarse de que el video esté reproduciendo
        if (videoElement.paused) {
          await videoElement.play();
        }
        
        // Detección específica para billetes y monedas
        if (targetObject.includes('billete') || targetObject.includes('moneda') || 
            targetObject.includes('dinero') || targetObject.includes('euro')) {
          await detectMoney(targetObject);
          isProcessing = false;
          return;
        }
        
        // Detectar objetos generales
        const predictions = await objectDetectionModel.detect(videoElement);
        
        if (predictions && predictions.length > 0) {
          // Buscar coincidencias con el objeto solicitado
          const matchingPredictions = predictions.filter(pred => {
            const translatedClass = translateObject(pred.class).toLowerCase();
            return translatedClass.includes(targetObject) || 
                   targetObject.includes(translatedClass);
          });
          
          if (matchingPredictions.length > 0) {
            const bestMatch = matchingPredictions[0];
            const object = translateObject(bestMatch.class);
            const confidence = Math.round(bestMatch.score * 100);
            
            speak(`He encontrado ${object} con ${confidence}% de confianza. Está ubicado en la ${getObjectPosition(bestMatch.bbox, videoElement)}.`);
          } else {
            // Si no hay coincidencia directa, intentar una clasificación más detallada con MobileNet
            const result = await imageClassificationModel.classify(videoElement);
            
            if (result && result.length > 0) {
              const matchingResults = result.filter(r => {
                return r.className.toLowerCase().includes(targetObject) ||
                       targetObject.includes(r.className.toLowerCase());
              });
              
              if (matchingResults.length > 0) {
                const bestMatch = matchingResults[0];
                speak(`Creo que he encontrado ${bestMatch.className} con ${Math.round(bestMatch.probability * 100)}% de confianza.`);
              } else {
                speak(`No he podido encontrar ${targetObject} en la imagen. Los objetos que veo son: ${predictions.map(p => translateObject(p.class)).join(', ')}.`);
              }
            } else {
              speak(`No he podido encontrar ${targetObject} en la imagen.`);
            }
          }
        } else {
          speak('No puedo identificar ningún objeto en este momento. Por favor, ajusta la cámara o prueba con mejor iluminación.');
        }
      } catch (error) {
        console.error('Error al detectar objeto específico:', error);
        speak('Ha ocurrido un error al analizar la imagen. Por favor, inténtalo de nuevo.');
      }
      
      isProcessing = false;
    }
    
    // Función específica para detectar dinero (billetes/monedas)
    async function detectMoney(request) {
      speak('Analizando el dinero...');
      
      const videoElement = document.getElementById('camera-feed');
      if (!videoElement || !cameraStream) {
        speak('Lo siento, no puedo acceder a la cámara.');
        return;
      }
      
      try {
        if (videoElement.paused) {
          await videoElement.play();
        }
        
        // Simulamos reconocimiento de billetes y monedas
        // En una implementación real, esto usaría un modelo especializado
        
        // Usar clasificación más detallada para billetes y monedas
        const result = await imageClassificationModel.classify(videoElement);
        
        let detected = false;
        
        if (result && result.length > 0) {
          for (const item of result) {
            const className = item.className.toLowerCase();
            
            // Para billetes
            if (request.includes('billete') && 
                (className.includes('bill') || className.includes('note') || className.includes('currency') || className.includes('money') || className.includes('euro'))) {
              
              // Simulación de denominaciones
              const denominations = [5, 10, 20, 50, 100, 200, 500];
              const denominationIndex = Math.floor(Math.random() * denominations.length);
              const amount = denominations[denominationIndex];
              
              speak(`He detectado un billete de ${amount} euros.`);
              detected = true;
              break;
            }
            
            // Para monedas
            if (request.includes('moneda') && 
                (className.includes('coin') || className.includes('currency') || className.includes('money') || className.includes('euro') || className.includes('cents'))) {
              
              // Simulación de denominaciones
              const denominations = [0.01, 0.02, 0.05, 0.10, 0.20, 0.50, 1, 2];
              const denominationIndex = Math.floor(Math.random() * denominations.length);
              const amount = denominations[denominationIndex];
              
              if (amount < 1) {
                const cents = amount * 100;
                speak(`He detectado una moneda de ${cents} céntimos de euro.`);
              } else {
                speak(`He detectado una moneda de ${amount} euros.`);
              }
              
              detected = true;
              break;
            }
          }
        }
        
        if (!detected) {
          speak('No he podido identificar correctamente el dinero. Por favor, asegúrate de que esté bien visible y con buena iluminación.');
        }
      } catch (error) {
        console.error('Error al detectar dinero:', error);
        speak('Ha ocurrido un error al analizar el dinero. Por favor, inténtalo de nuevo.');
      }
    }
    
    // Función para leer precios
    async function readPrice(command) {
      speak('Buscando información de precio...');
      
      // Extraer qué producto está solicitando
      let targetProduct = '';
      const keywords = [
        'precio de', 'cuesta', 'vale', 'cuánto es', 'cuanto es', 'cuánto cuesta', 'cuanto cuesta'
      ];
      
      for (const keyword of keywords) {
        if (command.includes(keyword)) {
          const parts = command.split(keyword);
          if (parts.length > 1 && parts[1].trim()) {
            targetProduct = parts[1].trim();
            break;
          }
        }
      }
      
      if (!targetProduct) {
        speak('No he entendido de qué producto quieres saber el precio. Por favor, especifica qué producto.');
        isProcessing = false;
        return;
      }
      
      const videoElement = document.getElementById('camera-feed');
      if (!videoElement || !cameraStream || !objectDetectionModel) {
        speak('Lo siento, no puedo acceder a la cámara.');
        isProcessing = false;
        return;
      }
      
      try {
        // Asegurarse de que el video esté reproduciendo
        if (videoElement.paused) {
          await videoElement.play();
        }
        
        // Para una demo, simulamos la detección de precios
        // En una implementación real, esto usaría OCR (Reconocimiento Óptico de Caracteres)
        
        // Primero detectamos si el objeto está en la imagen
        const predictions = await objectDetectionModel.detect(videoElement);
        const matchingPredictions = predictions.filter(pred => {
          const translatedClass = translateObject(pred.class).toLowerCase();
          return translatedClass.includes(targetProduct) || 
                targetProduct.includes(translatedClass);
        });
        
        if (matchingPredictions.length > 0) {
          // Objeto encontrado, simulamos precio
          const price = (Math.random() * 10 + 0.99).toFixed(2);
          speak(`El precio de ${targetProduct} es ${price} euros.`);
        } else {
          // Intentamos con clasificación más detallada
          const result = await imageClassificationModel.classify(videoElement);
          const matchingResults = result.filter(r => {
            return r.className.toLowerCase().includes(targetProduct) ||
                  targetProduct.includes(r.className.toLowerCase());
          });
          
          if (matchingResults.length > 0) {
            const price = (Math.random() * 10 + 0.99).toFixed(2);
            speak(`El precio de ${targetProduct} parece ser ${price} euros.`);
          } else {
            speak(`No he podido encontrar ${targetProduct} en la imagen. Por favor, asegúrate de que el producto está en el campo de visión de la cámara.`);
          }
        }
      } catch (error) {
        console.error('Error al leer precio:', error);
        speak('Ha ocurrido un error al analizar el precio. Por favor, inténtalo de nuevo.');
      }
      
      isProcessing = false;
    }
    
    // Función para indicaciones de navegación
    function provideNavigation(command) {
      // Extraer el destino solicitado
      let destination = '';
      const keywords = [
        'cómo llegar a', 'como llegar a', 'llegar a', 'guíame a', 'guiame a', 'dirección a', 'direccion a'
      ];
      
      for (const keyword of keywords) {
        if (command.includes(keyword)) {
          const parts = command.split(keyword);
          if (parts.length > 1 && parts[1].trim()) {
            destination = parts[1].trim();
            break;
          }
        }
      }
      
      if (!destination) {
        speak('No he entendido a dónde quieres ir. Por favor, especifica el destino.');
        isProcessing = false;
        return;
      }
      
      // Simular indicaciones de navegación
      speak(`Para llegar a ${destination}, sigue estas indicaciones: Primero, avanza recto unos 10 metros. Luego, gira a la derecha y continúa por 15 metros. A continuación, gira a la izquierda en la intersección. Tu destino estará a unos 20 metros a tu izquierda.`);
      
      isProcessing = false;
    }
    
    // Función para traducir los nombres de objetos del inglés al español
    function translateObject(objectClass) {
      const translations = {
        'person': 'persona',
        'bicycle': 'bicicleta',
        'car': 'coche',
        'motorcycle': 'motocicleta',
        'airplane': 'avión',
        'bus': 'autobús',
        'train': 'tren',
        'truck': 'camión',
        'boat': 'barco',
        'traffic light': 'semáforo',
        'fire hydrant': 'boca de incendios',
        'stop sign': 'señal de stop',
        'parking meter': 'parquímetro',
        'bench': 'banco',
        'bird': 'pájaro',
        'cat': 'gato',
        'dog': 'perro',
        'horse': 'caballo',
        'sheep': 'oveja',
        'cow': 'vaca',
        'elephant': 'elefante',
        'bear': 'oso',
        'zebra': 'cebra',
        'giraffe': 'jirafa',
        'backpack': 'mochila',
        'umbrella': 'paraguas',
        'handbag': 'bolso',
        'tie': 'corbata',
        'suitcase': 'maleta',
        'frisbee': 'frisbee',
        'skis': 'esquís',
        'snowboard': 'snowboard',
        'sports ball': 'pelota deportiva',
        'kite': 'cometa',
        'baseball bat': 'bate de béisbol',
        'baseball glove': 'guante de béisbol',
        'skateboard': 'monopatín',
        'surfboard': 'tabla de surf',
        'tennis racket': 'raqueta de tenis',
        'bottle': 'botella',
        'wine glass': 'copa de vino',
        'cup': 'taza',
        'fork': 'tenedor',
        'knife': 'cuchillo',
        'spoon': 'cuchara',
        'bowl': 'cuenco',
        'banana': 'plátano',
        'apple': 'manzana',
        'sandwich': 'sándwich',
        'orange': 'naranja',
        'broccoli': 'brócoli',
        'carrot': 'zanahoria',
        'hot dog': 'perrito caliente',
        'pizza': 'pizza',
        'donut': 'donut',
        'cake': 'pastel',
        'chair': 'silla',
        'couch': 'sofá',
        'potted plant': 'planta en maceta',
        'bed': 'cama',
        'dining table': 'mesa de comedor',
        'toilet': 'inodoro',
        'tv': 'televisor',
        'laptop': 'portátil',
        'mouse': 'ratón',
        'remote': 'mando a distancia',
        'keyboard': 'teclado',
        'cell phone': 'teléfono móvil',
        'microwave': 'microondas',
        'oven': 'horno',
        'toaster': 'tostadora',
        'sink': 'fregadero',
        'refrigerator': 'refrigerador',
        'book': 'libro',
        'clock': 'reloj',
        'vase': 'jarrón',
        'scissors': 'tijeras',
        'teddy bear': 'osito de peluche',
        'hair drier': 'secador de pelo',
        'toothbrush': 'cepillo de dientes',
        'water bottle': 'botella de agua',
        'juice': 'zumo',
        'orange juice': 'zumo de naranja'
      };
      
      return translations[objectClass.toLowerCase()] || objectClass;
    }
    
    // Función para determinar la posición relativa de un objeto en la imagen
    function getObjectPosition(bbox, videoElement) {
      const [x, y, width, height] = bbox;
      const centerX = x + width / 2;
      const centerY = y + height / 2;
      
      const videoWidth = videoElement.videoWidth;
      const videoHeight = videoElement.videoHeight;
      
      let horizontalPosition, verticalPosition;
      
      if (centerX < videoWidth / 3) {
        horizontalPosition = 'parte izquierda';
      } else if (centerX > (videoWidth * 2) / 3) {
        horizontalPosition = 'parte derecha';
      } else {
        horizontalPosition = 'parte central';
      }
      
      if (centerY < videoHeight / 3) {
        verticalPosition = 'superior';
      } else if (centerY > (videoHeight * 2) / 3) {
        verticalPosition = 'inferior';
      } else {
        verticalPosition = 'central';
      }
      
      return `${horizontalPosition} ${verticalPosition}`;
    }
    
    // Función para inicializar la cámara
    async function initCamera() {
      try {
        console.log('Solicitando acceso a la cámara...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        
        const videoElement = document.getElementById('camera-feed');
        videoElement.srcObject = stream;
        cameraStream = stream;
        
        console.log('Cámara inicializada correctamente');
      } catch (error) {
        console.error('Error al acceder a la cámara:', error);
        speak('No he podido acceder a la cámara. Por favor, asegúrate de dar permisos.');
        throw error;
      }
    }
    
    // Función para inicializar el micrófono
    async function initMicrophone() {
      try {
        console.log('Solicitando acceso al micrófono...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        microphoneStream = stream;
        console.log('Micrófono inicializado correctamente');
      } catch (error) {
        console.error('Error al acceder al micrófono:', error);
        speak('No he podido acceder al micrófono. Por favor, asegúrate de dar permisos.');
        throw error;
      }
    }
    
    // Función para obtener indicaciones de navegación
    async function getNavigation(command) {
      const destino = command.replace(/cómo llegar a|guíame a|navegar a|ir a/gi, '').trim();
      
      if (!destino) {
        return "Por favor, dime a dónde quieres ir. Por ejemplo: ¿Cómo llegar al supermercado?";
      }
      
      // Simulación de navegación paso a paso
      const indicaciones = {
        'supermercado': [
          "Para ir al supermercado:",
          "1. Sal de casa y gira a la derecha",
          "2. Camina recto unos 100 metros hasta el semáforo",
          "3. Cruza la calle cuando escuches el sonido del semáforo",
          "4. Continúa recto 50 metros más",
          "5. El supermercado estará a tu izquierda, escucharás las puertas automáticas"
        ],
        'farmacia': [
          "Para ir a la farmacia:",
          "1. Sal de casa y gira a la izquierda",
          "2. Camina hasta la esquina, aproximadamente 30 metros",
          "3. Gira a la derecha en la esquina",
          "4. La farmacia está a 20 metros, tiene una puerta con campanilla"
        ],
        'parada de autobús': [
          "Para ir a la parada de autobús:",
          "1. Sal de casa y ve recto",
          "2. Camina unos 50 metros hasta sentir el bordillo",
          "3. La parada está justo ahí, busca el poste metálico a tu derecha"
        ],
        'banco': [
          "Para ir al banco:",
          "1. Sal y gira a la derecha",
          "2. En la primera esquina, gira a la izquierda",
          "3. Camina 200 metros, pasarás dos cruces",
          "4. El banco está en la esquina siguiente, tiene puertas giratorias"
        ]
      };
      
      // Buscar coincidencias parciales
      let indicacionEncontrada = null;
      for (const [lugar, pasos] of Object.entries(indicaciones)) {
        if (destino.toLowerCase().includes(lugar) || lugar.includes(destino.toLowerCase())) {
          indicacionEncontrada = pasos;
          break;
        }
      }
      
      if (indicacionEncontrada) {
        return indicacionEncontrada.join('\n');
      } else {
        return `No tengo indicaciones específicas para "${destino}". ` +
               "Puedo guiarte al supermercado, farmacia, parada de autobús o banco. " +
               "¿A cuál de estos lugares quieres ir?";
      }
    }
    
    // Función para mantener la cámara activa
    function keepCameraAlive() {
      if (cameraStream) {
        const videoElement = document.getElementById('camera-feed');
        
        // Asegurarse de que el video esté reproduciendo
        if (videoElement.paused) {
          videoElement.play().catch(e => console.log('Error al mantener la cámara activa:', e));
        }
        
        // Verificar que las pistas estén activas
        cameraStream.getVideoTracks().forEach(track => {
          if (!track.enabled) {
            track.enabled = true;
          }
        });
        
        // Llamar recursivamente cada 5 segundos
        setTimeout(keepCameraAlive, 5000);
      }
    }
    
    // Función para mantener el micrófono activo
    function keepMicrophoneAlive() {
      if (microphoneStream) {
        // Verificar que las pistas estén activas
        microphoneStream.getAudioTracks().forEach(track => {
          if (!track.enabled) {
            track.enabled = true;
          }
        });
        
        // Llamar recursivamente cada 5 segundos
        setTimeout(keepMicrophoneAlive, 5000);
      }
    }

    // Inicializar dispositivos cuando la página se cargue
    window.addEventListener('DOMContentLoaded', async function() {
      console.log('=== INICIALIZANDO SISTEMA DE VOZ ===');
      
      // Primero inicializar el reconocimiento de voz
      console.log('1. Inicializando reconocimiento de voz...');
      if (initSpeechRecognition()) {
        console.log('✓ Reconocimiento de voz listo');
      } else {
        console.error('✗ Fallo al inicializar reconocimiento de voz');
      }
      
      // Luego inicializar los modelos de objetos (no crítico)
      console.log('2. Cargando modelos de IA...');
      initObjectDetection().catch(e => console.error('Error con modelos:', e));
      
      // Configurar activación por teclado (barra espaciadora)
      document.addEventListener('keydown', function(event) {
        if (event.code === 'Space' && !isListening && !isProcessing) {
          event.preventDefault();
          console.log('Barra espaciadora presionada');
          startListening();
        }
      });
      
      // Inicializar cámara y micrófono (no crítico para el funcionamiento básico)
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        console.log('3. Solicitando permisos de dispositivos...');
        // Solo solicitar micrófono primero
        try {
          await initMicrophone();
          console.log('✓ Micrófono inicializado');
          keepMicrophoneAlive();
        } catch (e) {
          console.error('✗ Error con micrófono:', e);
        }
        
        // Cámara es opcional
        initCamera().then(() => {
          console.log('✓ Cámara inicializada');
          keepCameraAlive();
        }).catch(e => console.log('ℹ Cámara no disponible:', e.message));
      }
      
      console.log('=== SISTEMA LISTO ===');
      console.log('Haz clic en el orbe o presiona la barra espaciadora para hablar');
    });

    // Asegurarse de que los dispositivos permanezcan activos cuando la página vuelve a estar visible
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        // Reactivar cámara
        if (cameraStream) {
          const videoElement = document.getElementById('camera-feed');
          if (videoElement) {
            videoElement.play().catch(e => console.log('Error al reanudar la cámara:', e));
          }
          
          // Reactivar las pistas de video
          cameraStream.getVideoTracks().forEach(track => {
            if (!track.enabled) {
              track.enabled = true;
              console.log('Pista de video reactivada');
            }
          });
        }
        
        // Reactivar micrófono
        if (microphoneStream) {
          microphoneStream.getAudioTracks().forEach(track => {
            if (!track.enabled) {
              track.enabled = true;
              console.log('Pista de audio reactivada');
            }
          });
        }
      }
    });
  </script>
  
  <script>
    /*
    // Comentado temporalmente Flutter para usar solo el asistente de voz
    window.addEventListener('load', function(ev) {
      // Mostrar la pantalla de carga con el orbe mientras se carga Flutter
      const loadingScreen = document.querySelector('.loading-screen');
      const flutterApp = document.getElementById('flutter-app');
      
      // Descarga el archivo main.dart.js
      _flutter.loader.loadEntrypoint({
        serviceWorker: {
          serviceWorkerVersion: serviceWorkerVersion,
        },
        onEntrypointLoaded: function(engineInitializer) {
          engineInitializer.initializeEngine({
            hostElement: document.querySelector('#flutter-app')
          }).then(function(appRunner) {
            // Una vez que Flutter está listo, mostrar la app y ocultar la pantalla de carga
            appRunner.runApp();
            
            // Dar tiempo para que Flutter se inicialice completamente
            setTimeout(function() {
              flutterApp.style.opacity = '1';
              loadingScreen.style.display = 'none';
            }, 2000);
          });
        }
      });
    });
    */
  </script>
</body>
</html>
